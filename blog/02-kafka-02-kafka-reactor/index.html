<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kafka High-Throughput Architecture: Demystifying the Reactor Pattern (Part 2) | Mingyan&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="What is the Reactor Pattern?
(Readers familiar with the Reactor pattern can skip to the Kafka&rsquo;s Reactor Implementation section)
Understanding the Reactor pattern requires starting with the evolution of fundamental network I/O models: from blocking I/O to multithreading and pooling techniques, then to non-blocking I/O, culminating in the Reactor pattern.
Blocking I/O, Non-blocking I/O, and Asynchronous I/O (AIO)
To discuss Reactor, we begin with the basic TCP network I/O processing flow. Programming languages typically provide a Socket API. First, create a listening Socket (serverSocket), bind it to a port, and listen. Then call the accept method to block and wait for client connections. When accept returns, you obtain a unique Socket (connectionSocket) representing that connection. Next, call read and write on this connectionSocket for data transfer.">
<meta name="author" content="">
<link rel="canonical" href="https://cyrilwongmy.github.io/blog/02-kafka-02-kafka-reactor/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://cyrilwongmy.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://cyrilwongmy.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://cyrilwongmy.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://cyrilwongmy.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://cyrilwongmy.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://cyrilwongmy.github.io/blog/02-kafka-02-kafka-reactor/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://cyrilwongmy.github.io/blog/02-kafka-02-kafka-reactor/">
  <meta property="og:site_name" content="Mingyan&#39;s blog">
  <meta property="og:title" content="Kafka High-Throughput Architecture: Demystifying the Reactor Pattern (Part 2)">
  <meta property="og:description" content="What is the Reactor Pattern? (Readers familiar with the Reactor pattern can skip to the Kafka’s Reactor Implementation section)
Understanding the Reactor pattern requires starting with the evolution of fundamental network I/O models: from blocking I/O to multithreading and pooling techniques, then to non-blocking I/O, culminating in the Reactor pattern.
Blocking I/O, Non-blocking I/O, and Asynchronous I/O (AIO) To discuss Reactor, we begin with the basic TCP network I/O processing flow. Programming languages typically provide a Socket API. First, create a listening Socket (serverSocket), bind it to a port, and listen. Then call the accept method to block and wait for client connections. When accept returns, you obtain a unique Socket (connectionSocket) representing that connection. Next, call read and write on this connectionSocket for data transfer.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2025-06-01T00:02:56-07:00">
    <meta property="article:modified_time" content="2025-06-01T00:02:56-07:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kafka High-Throughput Architecture: Demystifying the Reactor Pattern (Part 2)">
<meta name="twitter:description" content="What is the Reactor Pattern?
(Readers familiar with the Reactor pattern can skip to the Kafka&rsquo;s Reactor Implementation section)
Understanding the Reactor pattern requires starting with the evolution of fundamental network I/O models: from blocking I/O to multithreading and pooling techniques, then to non-blocking I/O, culminating in the Reactor pattern.
Blocking I/O, Non-blocking I/O, and Asynchronous I/O (AIO)
To discuss Reactor, we begin with the basic TCP network I/O processing flow. Programming languages typically provide a Socket API. First, create a listening Socket (serverSocket), bind it to a port, and listen. Then call the accept method to block and wait for client connections. When accept returns, you obtain a unique Socket (connectionSocket) representing that connection. Next, call read and write on this connectionSocket for data transfer.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://cyrilwongmy.github.io/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Kafka High-Throughput Architecture: Demystifying the Reactor Pattern (Part 2)",
      "item": "https://cyrilwongmy.github.io/blog/02-kafka-02-kafka-reactor/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kafka High-Throughput Architecture: Demystifying the Reactor Pattern (Part 2)",
  "name": "Kafka High-Throughput Architecture: Demystifying the Reactor Pattern (Part 2)",
  "description": "What is the Reactor Pattern? (Readers familiar with the Reactor pattern can skip to the Kafka\u0026rsquo;s Reactor Implementation section)\nUnderstanding the Reactor pattern requires starting with the evolution of fundamental network I/O models: from blocking I/O to multithreading and pooling techniques, then to non-blocking I/O, culminating in the Reactor pattern.\nBlocking I/O, Non-blocking I/O, and Asynchronous I/O (AIO) To discuss Reactor, we begin with the basic TCP network I/O processing flow. Programming languages typically provide a Socket API. First, create a listening Socket (serverSocket), bind it to a port, and listen. Then call the accept method to block and wait for client connections. When accept returns, you obtain a unique Socket (connectionSocket) representing that connection. Next, call read and write on this connectionSocket for data transfer.\n",
  "keywords": [
    
  ],
  "articleBody": "What is the Reactor Pattern? (Readers familiar with the Reactor pattern can skip to the Kafka’s Reactor Implementation section)\nUnderstanding the Reactor pattern requires starting with the evolution of fundamental network I/O models: from blocking I/O to multithreading and pooling techniques, then to non-blocking I/O, culminating in the Reactor pattern.\nBlocking I/O, Non-blocking I/O, and Asynchronous I/O (AIO) To discuss Reactor, we begin with the basic TCP network I/O processing flow. Programming languages typically provide a Socket API. First, create a listening Socket (serverSocket), bind it to a port, and listen. Then call the accept method to block and wait for client connections. When accept returns, you obtain a unique Socket (connectionSocket) representing that connection. Next, call read and write on this connectionSocket for data transfer.\n# Server socket listening for incoming connections serverSocket = Socket() serverSocket.bind(port, server_ip) connectionSocket = serverSocket.accept() # Blocks until a client connects # Read and write with the connected client connectionSocket.read(buffer) # Blocks reading data from network into buffer connectionSocket.write(buffer) # Blocks writing data from buffer to network As shown above, read and write are blocking system calls. Program execution halts (blocks) at the read line until:\nThe client sends data. Data is read from the NIC into the kernel buffer. Data is copied from the kernel buffer to the program’s user-space buffer (buffer). This means the thread cannot perform other tasks while blocked. Ideally, the thread could handle other tasks while waiting for steps 1 and 2 (especially time-consuming), returning only when the data is ready in user space. This is the goal of Asynchronous I/O (AIO).\nIn Linux 5.1+ kernels, io_uring provides truly asynchronous read/write supporting all steps 1-3. However, io_uring’s shared memory approach for high performance introduces potential security considerations.\nPrior to io_uring, Linux’s AIO support was mostly simulated in user space with limitations (e.g., inadequate buffered I/O support). The more traditional approach for high-performance servers is NIO (Non-blocking I/O). While the OS handles steps 1-2 (data arriving in the kernel), and non-blocking Socket calls ensure read/write don’t block themselves, the user thread still needs to poll or wait for event notifications (like epoll) to know when data is ready in user space (step 3). Kafka achieves its high throughput using NIO (specifically epoll).\nAfter optimizing the blocking issues with read/write, a single thread’s network I/O efficiency improves significantly as it can utilize the CPU more fully.\nThe pseudo-code above shows a simple model. To handle many concurrent clients, each connection requires its own thread/process. After the main thread **accept**s a connection, it hands the connectionSocket to a dedicated worker thread, which executes the read and write logic.\nMultithreaded I/O and Pooling The C10K problem (10,000 concurrent connections per machine) is common in modern internet systems. Creating one thread per client connection would cause server threads to surge (potentially tens of thousands), while modern CPUs typically have only dozens of cores (including hyper-threading). Excessive threads lead to frequent context switches and CPU cache thrashing, severely degrading performance.\nUsing Pooling, we create a fixed-size thread pool. The main thread only **accept**s connections and hands the connectionSocket to a worker thread in the pool for read/write operations. This prevents unbounded thread creation and limits resource consumption.\nReactor Pattern The Reactor pattern has several variants, with flexible combinations of Acceptor, Processor (or SubReactor), and Handler roles.\nWe focus on the form similar to Kafka’s design:\nMain Reactor: Typically single-threaded. Listens for connection request events (accept) and dispatches new connections to the Acceptor. Acceptor: Completes the actual connection establishment (accept returns connectionSocket) and registers the connection with a SubReactor. SubReactor: Usually multiple instances (each bound to a Selector/epoll). Monitors read/write events (read, write) on established connections. Upon detecting events, it delegates I/O tasks to Handlers. Handler: Worker threads in a pool. Execute actual business logic (e.g., computation, disk I/O, or other time-consuming operations). The MainReactor and SubReactor only focus on rapid event dispatch (hence “Reactor”). They do not handle business logic.\nThe MainReactor handles only connection events, making it extremely efficient. Time-consuming tasks (connection setup, I/O) are delegated to the Acceptor, SubReactors, and Handlers. Components communicate via task queues (e.g., MainReactor queues new connections, Acceptor consumes the queue), decoupling them, smoothing traffic bursts, and enhancing load capacity.\nDepending on application needs, designs can have M Reactors and N Handlers. The Reactor pattern is highly flexible. For example, Redis uses a single Reactor with a single-threaded Handler because its primary operations are in-memory reads/writes with no CPU-intensive tasks—bottlenecks are mainly network I/O. Handlers and Reactors can even be separate processes, though this involves complex IPC.\nProactor Pattern The Proactor pattern builds upon truly asynchronous I/O (AIO). It aims to eliminate the Reactor’s limitation where user threads still wait for data copying (step 3), pursuing ultimate performance. It can be seen as an enhanced Reactor: Handlers submit I/O operations (e.g., read/write) to the kernel. After the kernel completes all steps (including data copying), it proactively notifies the user thread that “data is ready in the user buffer,” allowing immediate processing. Future articles will compare NIO and AIO performance.\nKafka’s Reactor Implementation A full implementation analysis would be lengthy. This section focuses on how Kafka’s request processing flow embodies the Reactor pattern.\nKafka employs a single Acceptor (Main Reactor) + multiple Processors (SubReactors) + multiple Handlers structure.\nCore Components and Flow Acceptor (Main Reactor): Uses a Selector (epoll) to listen for connection events (OP_ACCEPT). Accepts new connections and distributes them to Processors. Processor (SubReactor): Each Processor has its own Selector (epoll). Monitors read/write events (OP_READ, OP_WRITE) on registered connections, performing network I/O (receiving requests, sending responses). RequestChannel (Task Queue): A BlockingQueue. Processors place parsed requests into this queue; Handlers consume requests from it. Decouples Processors and Handlers, providing buffering and load leveling. KafkaRequestHandler (Handler): Worker thread pool. Executes business logic (processes requests, generates responses). Acceptor The Acceptor class extends Java’s Thread. Upon startup (start()), it creates the server listening SocketChannel (serverChannel), starts all Processor threads, then starts its own thread (run()).\ndef start(): Unit = synchronized { // ... (details omitted for clarity) serverChannel = openServerSocket(endPoint.host, endPoint.port, listenBacklogSize) processors.foreach(_.start()) // Start all Processor threads thread.start() // Start the Acceptor thread itself (calls run()) started.set(true) } The run() method core is a loop: register serverChannel for OP_ACCEPT events with the Selector, then repeatedly call acceptNewConnections(). A key design is catching all Throwable to prevent thread death and service disruption.\n/** * Accept loop that checks for new connection attempts */ override def run(): Unit = { serverChannel.register(nioSelector, SelectionKey.OP_ACCEPT) try { while (shouldRun.get()) { try { acceptNewConnections() closeThrottledConnections() } catch { // Catch all throwables to prevent thread exit on exceptions (e.g., bad request, channel issue). // Ensures broker keeps serving other clients. case e: ControlThrowable =\u003e throw e case e: Throwable =\u003e error(\"Error occurred\", e) } } } finally { closeAll() } } acceptNewConnections() is the core logic: Use selector.select() to detect OP_ACCEPT events. For each ready SelectionKey, call accept() to get the client SocketChannel. Then, using a round-robin strategy, assign this SocketChannel to a Processor (via assignNewConnection(socketChannel, processor), placing it in the Processor’s newConnections queue).\n/** * Listen for new connections and assign accepted connections to processors using round-robin. */ private def acceptNewConnections(): Unit = { val ready = nioSelector.select(500) if (ready \u003e 0) { val keys = nioSelector.selectedKeys() val iter = keys.iterator() while (iter.hasNext \u0026\u0026 shouldRun.get()) { try { val key = iter.next iter.remove() if (key.isAcceptable) { accept(key).foreach { socketChannel =\u003e // Assign the channel to the next processor (using round-robin) to which the // channel can be added without blocking. If newConnections queue is full on // all processors, block until the last one is able to accept a connection. var retriesLeft = synchronized(processors.length) var processor: Processor = null do { retriesLeft -= 1 processor = synchronized { // adjust the index (if necessary) and retrieve the processor atomically for // correct behaviour in case the number of processors is reduced dynamically currentProcessorIndex = currentProcessorIndex % processors.length processors(currentProcessorIndex) } currentProcessorIndex += 1 } while (!assignNewConnection(socketChannel, processor, retriesLeft == 0)) } } else throw new IllegalStateException(\"Unrecognized key state for acceptor thread.\") } catch { case e: Throwable =\u003e error(\"Error while accepting connection\", e) } } } } Processor Processor is also a thread (Thread). Its start() method launches the thread (run()).\ndef start(): Unit = { if (!started.getAndSet(true)) { thread.start() } } The run() method is the processing core, containing a main loop with key steps:\noverride def run(): Unit = { try { while (shouldRun.get()) { try { configureNewConnections() // Setup new connections queued by Acceptor processNewResponses() // Prepare responses for sending poll() // Perform network I/O (epoll) processCompletedReceives() // Handle received requests processCompletedSends() // Handle completed sends processDisconnected() // Handle disconnected clients closeExcessConnections() // Enforce connection quotas } catch { // Catch all throwables to keep the processor thread running. case e: Throwable =\u003e processException(\"Processor got uncaught exception.\", e) } } } finally { debug(s\"Closing selector - processor $id\") CoreUtils.swallow(closeAll(), this, Level.ERROR) } } configureNewConnections Takes **SocketChannel**s from the newConnections queue (populated by Acceptor) and registers them with the Processor’s own dedicated Selector, initially listening only for OP_READ events.\nprivate def configureNewConnections(): Unit = { var connectionsProcessed = 0 while (connectionsProcessed \u003c connectionQueueSize \u0026\u0026 !newConnections.isEmpty) { val channel = newConnections.poll() try { debug(s\"Processor $id listening to new connection from ${channel.socket.getRemoteSocketAddress}\") selector.register(connectionId(channel.socket), channel) // Register with Processor's own Selector (for OP_READ) connectionsProcessed += 1 } catch { case e: Throwable =\u003e val remoteAddress = channel.socket.getRemoteSocketAddress connectionQuotas.closeChannel(this, listenerName, channel) // Cleanup on error processException(s\"Processor $id closed connection from $remoteAddress\", e) } } } processNewResponses Processes responses to be sent. Each Processor has a dedicated response queue (responseQueue). After processing a request, Handlers place the response into the corresponding Processor’s responseQueue. This method:\nChecks if the associated Channel is closed. Converts the Response into a network-ready packet (NetworkSend) and associates it with the Channel. Registers OP_WRITE events for the Channel (if not already registered). (Note: Kafka uses a mute/unmute mechanism to manage per-Channel event registration, ensuring a Channel never has multiple in-flight requests/responses. Details covered later). poll Core network I/O operation. Calls Selector.poll(pollTimeout) (performing epoll_wait), handling all ready OP_READ and OP_WRITE events:\nOP_READ: Reads data, handles TCP packet coalescing/splitting, assembles full requests.\nOP_WRITE: Sends the NetworkSend data associated with the Channel.\n(Complex internals involving Selector implementation, NetworkReceive/NetworkSend, mute, etc., are covered in subsequent articles).\nprocessCompletedReceives / processCompletedSends processCompletedReceives handles fully assembled requests (NetworkReceive) from the poll() phase:\nParses NetworkReceive into a Kafka protocol Request object. Places the Request into the RequestChannel queue for Handler processing. processCompletedSends handles successfully sent responses (NetworkSend) from the poll() phase:\nPerforms cleanup (e.g., releases ByteBuffer). Unmutes the Channel (calls unmute()) to allow it to listen for OP_READ events again (related to mute mechanism). RequestChannel Acts as the task queue between Processors and Handlers. Core is a BlockingQueue.\nclass RequestChannel(val queueSize: Int, ...) { import RequestChannel._ private val requestQueue = new ArrayBlockingQueue[BaseRequest](queueSize) // Core Blocking Queue // ... (other fields and methods) } Processor (Producer): Calls RequestChannel.sendRequest(request) to enqueue parsed requests. Handler (Consumer): Calls RequestChannel.receiveRequest(timeout) to dequeue requests for processing. KafkaRequestHandler Threads in the worker thread pool (KafkaRequestHandlerPool). Their run() method loops to get requests from the RequestChannel (receiveRequest) and dispatches them to KafkaApis.handle(request).\noverride def run(): Unit = { // ... loop ... val req = requestChannel.receiveRequest() // Get request from queue apis.handle(req, requestLocal) // Dispatch to KafkaApis for processing // ... } KafkaApis.handle() is the entry point to Kafka’s business logic. It routes requests based on type (ApiKeys) to specific handlers (e.g., handleProduceRequest, handleFetchRequest).\n/** * Top-level method that handles all requests and multiplexes to the right api */ override def handle(request: RequestChannel.Request, requestLocal: RequestLocal): Unit = { try { trace(s\"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};...\") if (!apiVersionManager.isApiEnabled(request.header.apiKey, request.header.apiVersion)) { throw new IllegalStateException(s\"API ${request.header.apiKey} with version ${request.header.apiVersion} is not enabled\") } request.header.apiKey match { // Dispatch based on request type case ApiKeys.PRODUCE =\u003e handleProduceRequest(request, requestLocal) case ApiKeys.FETCH =\u003e handleFetchRequest(request) case ApiKeys.LIST_OFFSETS =\u003e handleListOffsetRequest(request) case ApiKeys.METADATA =\u003e handleTopicMetadataRequest(request) case ApiKeys.OFFSET_COMMIT =\u003e handleOffsetCommitRequest(request, requestLocal) // ... (handlers for all other API keys) ... case ApiKeys.API_VERSIONS =\u003e handleApiVersionsRequest(request) } } catch { case e: Throwable =\u003e requestHelper.handleError(request, e) // Handle processing errors } } After processing, the Handler constructs a Response and sends it back to the corresponding Processor via RequestChannel.sendResponse() (using the associated response queue). The Processor then sends it to the client.\nSummary This article dissected how Kafka leverages the Reactor pattern (Single Acceptor + Multiple Processors + RequestChannel Queue + Handler Thread Pool) to achieve high-throughput network processing:\nAcceptor efficiently accepts and distributes new connections. Processor uses NIO (epoll) to efficiently handle I/O events for many connections (I/O-bound). RequestChannel decouples network I/O (Processor) from business processing (Handler), buffering requests. Handler thread pool focuses on business logic (CPU/disk-bound). This architecture effectively isolates different task stages, maximizes multi-core CPU utilization, and smooths traffic fluctuations via queue buffering, forming the foundation of Kafka’s high throughput and concurrency.\nWe focused on the request flow mapping to the Reactor pattern, omitting details like network I/O (packet handling, Selector internals, mute mechanism), request parsing, and Handler internals. These will be explored in future articles.\n",
  "wordCount" : "2174",
  "inLanguage": "en",
  "datePublished": "2025-06-01T00:02:56-07:00",
  "dateModified": "2025-06-01T00:02:56-07:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cyrilwongmy.github.io/blog/02-kafka-02-kafka-reactor/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mingyan's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cyrilwongmy.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://cyrilwongmy.github.io/" accesskey="h" title="Mingyan&#39;s blog (Alt + H)">Mingyan&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Kafka High-Throughput Architecture: Demystifying the Reactor Pattern (Part 2)
    </h1>
    <div class="post-meta"><span title='2025-06-01 00:02:56 -0700 PDT'>June 1, 2025</span>

</div>
  </header> 
  <div class="post-content"><h1 id="what-is-the-reactor-pattern">What is the Reactor Pattern?<a hidden class="anchor" aria-hidden="true" href="#what-is-the-reactor-pattern">#</a></h1>
<p><em>(Readers familiar with the Reactor pattern can skip to the <a href="#kafka-s-reactor-implementation">Kafka&rsquo;s Reactor Implementation</a> section)</em></p>
<p>Understanding the Reactor pattern requires starting with the evolution of fundamental network I/O models: from blocking I/O to multithreading and pooling techniques, then to non-blocking I/O, culminating in the Reactor pattern.</p>
<h2 id="blocking-io-non-blocking-io-and-asynchronous-io-aio">Blocking I/O, Non-blocking I/O, and Asynchronous I/O (AIO)<a hidden class="anchor" aria-hidden="true" href="#blocking-io-non-blocking-io-and-asynchronous-io-aio">#</a></h2>
<p>To discuss Reactor, we begin with the basic TCP network I/O processing flow. Programming languages typically provide a <strong><code>Socket</code></strong> API. First, create a listening <strong><code>Socket</code></strong> (<strong><code>serverSocket</code></strong>), <strong><code>bind</code></strong> it to a port, and <strong><code>listen</code></strong>. Then call the <strong><code>accept</code></strong> method to <strong>block</strong> and wait for client connections. When <strong><code>accept</code></strong> returns, you obtain a unique <strong><code>Socket</code></strong> (<strong><code>connectionSocket</code></strong>) representing that connection. Next, call <strong><code>read</code></strong> and <strong><code>write</code></strong> on this <strong><code>connectionSocket</code></strong> for data transfer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Server socket listening for incoming connections</span>
</span></span><span style="display:flex;"><span>serverSocket <span style="color:#f92672">=</span> Socket()
</span></span><span style="display:flex;"><span>serverSocket<span style="color:#f92672">.</span>bind(port, server_ip)
</span></span><span style="display:flex;"><span>connectionSocket <span style="color:#f92672">=</span> serverSocket<span style="color:#f92672">.</span>accept()  <span style="color:#75715e"># Blocks until a client connects</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Read and write with the connected client</span>
</span></span><span style="display:flex;"><span>connectionSocket<span style="color:#f92672">.</span>read(buffer)  <span style="color:#75715e"># Blocks reading data from network into buffer</span>
</span></span><span style="display:flex;"><span>connectionSocket<span style="color:#f92672">.</span>write(buffer) <span style="color:#75715e"># Blocks writing data from buffer to network</span>
</span></span></code></pre></div><p>As shown above, <strong><code>read</code></strong> and <strong><code>write</code></strong> are <strong>blocking</strong> system calls. Program execution halts (blocks) at the <strong><code>read</code></strong> line until:</p>
<ol>
<li>The client sends data.</li>
<li>Data is read from the NIC into the kernel buffer.</li>
<li>Data is copied from the kernel buffer to the program&rsquo;s user-space buffer (<strong><code>buffer</code></strong>).</li>
</ol>
<p>This means the thread cannot perform other tasks while blocked. Ideally, the thread could handle other tasks while waiting for steps 1 and 2 (especially time-consuming), returning only when the data is ready in user space. This is the goal of <strong>Asynchronous I/O (AIO)</strong>.</p>
<p>In Linux 5.1+ kernels, <strong><code>io_uring</code></strong> provides truly asynchronous <strong><code>read</code></strong>/<strong><code>write</code></strong> supporting all steps 1-3. However, <strong><code>io_uring</code></strong>&rsquo;s shared memory approach for high performance introduces <a href="https://en.wikipedia.org/wiki/Io_uring">potential security considerations</a>.</p>
<p>Prior to <strong><code>io_uring</code></strong>, Linux&rsquo;s AIO support was mostly simulated in user space with limitations (e.g., inadequate buffered I/O support). The more traditional approach for high-performance servers is <strong>NIO (Non-blocking I/O)</strong>. While the OS handles steps 1-2 (data arriving in the kernel), and non-blocking Socket calls ensure <strong><code>read</code></strong>/<strong><code>write</code></strong> don&rsquo;t block themselves, <strong>the user thread still needs to poll or wait for event notifications (like <code>epoll</code>) to know when data is ready in user space (step 3)</strong>. Kafka achieves its high throughput using NIO (specifically <strong><code>epoll</code></strong>).</p>
<p>After optimizing the blocking issues with <strong><code>read</code></strong>/<strong><code>write</code></strong>, <strong>a single thread&rsquo;s network I/O efficiency improves significantly</strong> as it can utilize the CPU more fully.</p>
<p>The pseudo-code above shows a simple model. To handle many concurrent clients, each connection requires its own thread/process. After the main thread **<code>accept</code>**s a connection, it hands the <strong><code>connectionSocket</code></strong> to a dedicated worker thread, which executes the <strong><code>read</code></strong> and <strong><code>write</code></strong> logic.</p>
<h2 id="multithreaded-io-and-pooling">Multithreaded I/O and Pooling<a hidden class="anchor" aria-hidden="true" href="#multithreaded-io-and-pooling">#</a></h2>
<p>The <a href="https://en.wikipedia.org/wiki/C10k_problem">C10K problem</a> (10,000 concurrent connections per machine) is common in modern internet systems. Creating one thread per client connection would cause server threads to surge (potentially tens of thousands), while modern CPUs typically have only dozens of cores (including hyper-threading). Excessive threads lead to frequent context switches and CPU cache thrashing, severely degrading performance.</p>
<p>Using <strong>Pooling</strong>, we create a <strong>fixed-size</strong> thread pool. The main thread only **<code>accept</code>**s connections and hands the <strong><code>connectionSocket</code></strong> to a worker thread in the pool for read/write operations. This prevents unbounded thread creation and limits resource consumption.</p>
<h2 id="reactor-pattern">Reactor Pattern<a hidden class="anchor" aria-hidden="true" href="#reactor-pattern">#</a></h2>
<p>The Reactor pattern has several variants, with flexible combinations of Acceptor, Processor (or SubReactor), and Handler roles.</p>
<p>We focus on the form similar to Kafka&rsquo;s design:</p>
<ol>
<li><strong>Main Reactor:</strong> Typically single-threaded. Listens for connection request events (<strong><code>accept</code></strong>) and dispatches new connections to the Acceptor.</li>
<li><strong>Acceptor:</strong> Completes the actual connection establishment (<strong><code>accept</code></strong> returns <strong><code>connectionSocket</code></strong>) and registers the connection with a SubReactor.</li>
<li><strong>SubReactor:</strong> Usually multiple instances (each bound to a <strong><code>Selector</code></strong>/<strong><code>epoll</code></strong>). Monitors read/write events (<strong><code>read</code></strong>, <strong><code>write</code></strong>) on established connections. Upon detecting events, it delegates I/O tasks to Handlers.</li>
<li><strong>Handler:</strong> Worker threads in a pool. Execute actual business logic (e.g., computation, disk I/O, or other time-consuming operations).</li>
</ol>
<p><img alt="Reactor Pattern" loading="lazy" src="https://raw.githubusercontent.com/cyrilwongmy/cyrilwongmy.github.io/main/assets/image/20250601001022.png"></p>
<p>The MainReactor and SubReactor <strong>only focus on rapid event dispatch</strong> (hence &ldquo;Reactor&rdquo;). They <strong>do not handle</strong> business logic.</p>
<p>The MainReactor handles only connection events, making it extremely efficient. Time-consuming tasks (connection setup, I/O) are delegated to the Acceptor, SubReactors, and Handlers. Components communicate via <strong>task queues</strong> (e.g., MainReactor queues new connections, Acceptor consumes the queue), decoupling them, smoothing traffic bursts, and enhancing load capacity.</p>
<p>Depending on application needs, designs can have <strong><code>M</code></strong> Reactors and <strong><code>N</code></strong> Handlers. The Reactor pattern is highly flexible. For example, Redis uses a <strong>single Reactor with a single-threaded Handler</strong> because its primary operations are in-memory reads/writes with no CPU-intensive tasks—bottlenecks are mainly network I/O. Handlers and Reactors can even be separate processes, though this involves complex IPC.</p>
<h2 id="proactor-pattern">Proactor Pattern<a hidden class="anchor" aria-hidden="true" href="#proactor-pattern">#</a></h2>
<p>The Proactor pattern builds upon <strong>truly asynchronous I/O (AIO)</strong>. It aims to eliminate the Reactor&rsquo;s limitation where user threads still wait for data copying (step 3), pursuing ultimate performance. It can be seen as an enhanced Reactor: Handlers submit I/O operations (e.g., <strong><code>read</code></strong>/<strong><code>write</code></strong>) to the kernel. After the kernel completes <strong>all steps (including data copying)</strong>, it proactively notifies the user thread that &ldquo;data is ready in the user buffer,&rdquo; allowing immediate processing. Future articles will compare NIO and AIO performance.</p>
<hr>
<h1 id="kafkas-reactor-implementation">Kafka&rsquo;s Reactor Implementation<a hidden class="anchor" aria-hidden="true" href="#kafkas-reactor-implementation">#</a></h1>
<p>A full implementation analysis would be lengthy. This section focuses on how Kafka&rsquo;s request processing flow embodies the Reactor pattern.</p>
<p>Kafka employs a <strong>single Acceptor (Main Reactor) + multiple Processors (SubReactors) + multiple Handlers</strong> structure.</p>
<h2 id="core-components-and-flow">Core Components and Flow<a hidden class="anchor" aria-hidden="true" href="#core-components-and-flow">#</a></h2>
<ol>
<li><strong>Acceptor (Main Reactor):</strong> Uses a <strong><code>Selector</code></strong> (<strong><code>epoll</code></strong>) to listen for connection events (<strong><code>OP_ACCEPT</code></strong>). Accepts new connections and distributes them to Processors.</li>
<li><strong>Processor (SubReactor):</strong> Each Processor has its own <strong><code>Selector</code></strong> (<strong><code>epoll</code></strong>). Monitors read/write events (<strong><code>OP_READ</code></strong>, <strong><code>OP_WRITE</code></strong>) on registered connections, performing network I/O (receiving requests, sending responses).</li>
<li><strong>RequestChannel (Task Queue):</strong> A <strong><code>BlockingQueue</code></strong>. Processors place parsed requests into this queue; Handlers consume requests from it. <strong>Decouples Processors and Handlers, providing buffering and load leveling.</strong></li>
<li><strong>KafkaRequestHandler (Handler):</strong> Worker thread pool. Executes business logic (processes requests, generates responses).</li>
</ol>
<p><img alt="Kafka&rsquo;s Reactor Implementation" loading="lazy" src="https://raw.githubusercontent.com/cyrilwongmy/cyrilwongmy.github.io/main/assets/image/20250601001118.png"></p>
<h2 id="acceptor">Acceptor<a hidden class="anchor" aria-hidden="true" href="#acceptor">#</a></h2>
<p>The <strong><code>Acceptor</code></strong> class extends Java&rsquo;s <strong><code>Thread</code></strong>. Upon startup (<strong><code>start()</code></strong>), it creates the server listening <strong><code>SocketChannel</code></strong> (<strong><code>serverChannel</code></strong>), starts all <strong><code>Processor</code></strong> threads, then starts its own thread (<strong><code>run()</code></strong>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> start<span style="color:#f92672">()</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Unit</span> <span style="color:#f92672">=</span> synchronized <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ... (details omitted for clarity)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    serverChannel <span style="color:#66d9ef">=</span> openServerSocket<span style="color:#f92672">(</span>endPoint<span style="color:#f92672">.</span>host<span style="color:#f92672">,</span> endPoint<span style="color:#f92672">.</span>port<span style="color:#f92672">,</span> listenBacklogSize<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    processors<span style="color:#f92672">.</span>foreach<span style="color:#f92672">(</span><span style="color:#66d9ef">_</span><span style="color:#f92672">.</span>start<span style="color:#f92672">())</span> <span style="color:#75715e">// Start all Processor threads
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    thread<span style="color:#f92672">.</span>start<span style="color:#f92672">()</span> <span style="color:#75715e">// Start the Acceptor thread itself (calls run())
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    started<span style="color:#f92672">.</span>set<span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>The <strong><code>run()</code></strong> method core is a loop: register <strong><code>serverChannel</code></strong> for <strong><code>OP_ACCEPT</code></strong> events with the <strong><code>Selector</code></strong>, then repeatedly call <strong><code>acceptNewConnections()</code></strong>. A key design is catching all <strong><code>Throwable</code></strong> to prevent thread death and service disruption.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Accept loop that checks for new connection attempts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">def</span> run<span style="color:#f92672">()</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Unit</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  serverChannel<span style="color:#f92672">.</span>register<span style="color:#f92672">(</span>nioSelector<span style="color:#f92672">,</span> <span style="color:#a6e22e">SelectionKey</span><span style="color:#f92672">.</span><span style="color:#a6e22e">OP_ACCEPT</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>shouldRun<span style="color:#f92672">.</span>get<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        acceptNewConnections<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>        closeThrottledConnections<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Catch all throwables to prevent thread exit on exceptions (e.g., bad request, channel issue).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Ensures broker keeps serving other clients.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">case</span> e<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">ControlThrowable</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">throw</span> e
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> e<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Throwable</span> <span style="color:#f92672">=&gt;</span> error<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Error occurred&#34;</span><span style="color:#f92672">,</span> e<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    closeAll<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong><code>acceptNewConnections()</code></strong> is the core logic: Use <strong><code>selector.select()</code></strong> to detect <strong><code>OP_ACCEPT</code></strong> events. For each ready <strong><code>SelectionKey</code></strong>, call <strong><code>accept()</code></strong> to get the client <strong><code>SocketChannel</code></strong>. Then, using a <strong>round-robin</strong> strategy, assign this <strong><code>SocketChannel</code></strong> to a <strong><code>Processor</code></strong> (via <strong><code>assignNewConnection(socketChannel, processor)</code></strong>, placing it in the Processor&rsquo;s <strong><code>newConnections</code></strong> queue).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Listen for new connections and assign accepted connections to processors using round-robin.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">def</span> acceptNewConnections<span style="color:#f92672">()</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Unit</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">val</span> ready <span style="color:#66d9ef">=</span> nioSelector<span style="color:#f92672">.</span>select<span style="color:#f92672">(</span><span style="color:#ae81ff">500</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ready <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> keys <span style="color:#66d9ef">=</span> nioSelector<span style="color:#f92672">.</span>selectedKeys<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> iter <span style="color:#66d9ef">=</span> keys<span style="color:#f92672">.</span>iterator<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>iter<span style="color:#f92672">.</span>hasNext <span style="color:#f92672">&amp;&amp;</span> shouldRun<span style="color:#f92672">.</span>get<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> key <span style="color:#66d9ef">=</span> iter<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span>        iter<span style="color:#f92672">.</span>remove<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key<span style="color:#f92672">.</span>isAcceptable<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          accept<span style="color:#f92672">(</span>key<span style="color:#f92672">).</span>foreach <span style="color:#f92672">{</span> socketChannel <span style="color:#66d9ef">=&gt;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Assign the channel to the next processor (using round-robin) to which the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// channel can be added without blocking. If newConnections queue is full on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// all processors, block until the last one is able to accept a connection.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">var</span> retriesLeft <span style="color:#66d9ef">=</span> synchronized<span style="color:#f92672">(</span>processors<span style="color:#f92672">.</span>length<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> processor<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Processor</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>              retriesLeft <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>              processor <span style="color:#66d9ef">=</span> synchronized <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// adjust the index (if necessary) and retrieve the processor atomically for
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#75715e">// correct behaviour in case the number of processors is reduced dynamically
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                currentProcessorIndex <span style="color:#66d9ef">=</span> currentProcessorIndex <span style="color:#f92672">%</span> processors<span style="color:#f92672">.</span>length
</span></span><span style="display:flex;"><span>                processors<span style="color:#f92672">(</span>currentProcessorIndex<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>              <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>              currentProcessorIndex <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>assignNewConnection<span style="color:#f92672">(</span>socketChannel<span style="color:#f92672">,</span> processor<span style="color:#f92672">,</span> retriesLeft <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">))</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">IllegalStateException</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Unrecognized key state for acceptor thread.&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> e<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Throwable</span> <span style="color:#f92672">=&gt;</span> error<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Error while accepting connection&#34;</span><span style="color:#f92672">,</span> e<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="processor">Processor<a hidden class="anchor" aria-hidden="true" href="#processor">#</a></h2>
<p><strong><code>Processor</code></strong> is also a thread (<strong><code>Thread</code></strong>). Its <strong><code>start()</code></strong> method launches the thread (<strong><code>run()</code></strong>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> start<span style="color:#f92672">()</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Unit</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>started<span style="color:#f92672">.</span>getAndSet<span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    thread<span style="color:#f92672">.</span>start<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>The <strong><code>run()</code></strong> method is the processing core, containing a main loop with key steps:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">def</span> run<span style="color:#f92672">()</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Unit</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>shouldRun<span style="color:#f92672">.</span>get<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          configureNewConnections<span style="color:#f92672">()</span> <span style="color:#75715e">// Setup new connections queued by Acceptor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          processNewResponses<span style="color:#f92672">()</span>     <span style="color:#75715e">// Prepare responses for sending
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          poll<span style="color:#f92672">()</span>                   <span style="color:#75715e">// Perform network I/O (epoll)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          processCompletedReceives<span style="color:#f92672">()</span> <span style="color:#75715e">// Handle received requests
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          processCompletedSends<span style="color:#f92672">()</span>   <span style="color:#75715e">// Handle completed sends
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          processDisconnected<span style="color:#f92672">()</span>     <span style="color:#75715e">// Handle disconnected clients
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          closeExcessConnections<span style="color:#f92672">()</span>  <span style="color:#75715e">// Enforce connection quotas
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// Catch all throwables to keep the processor thread running.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>          <span style="color:#66d9ef">case</span> e<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Throwable</span> <span style="color:#f92672">=&gt;</span> processException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Processor got uncaught exception.&#34;</span><span style="color:#f92672">,</span> e<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      debug<span style="color:#f92672">(</span><span style="color:#e6db74">s&#34;Closing selector - processor </span><span style="color:#e6db74">$id</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">CoreUtils</span><span style="color:#f92672">.</span>swallow<span style="color:#f92672">(</span>closeAll<span style="color:#f92672">(),</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> <span style="color:#a6e22e">Level</span><span style="color:#f92672">.</span><span style="color:#a6e22e">ERROR</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="configurenewconnections">configureNewConnections<a hidden class="anchor" aria-hidden="true" href="#configurenewconnections">#</a></h2>
<p>Takes **<code>SocketChannel</code>**s from the <strong><code>newConnections</code></strong> queue (populated by Acceptor) and registers them with the <em>Processor&rsquo;s own dedicated <strong><code>Selector</code></strong></em>, initially listening only for <strong><code>OP_READ</code></strong> events.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">def</span> configureNewConnections<span style="color:#f92672">()</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Unit</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> connectionsProcessed <span style="color:#66d9ef">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>connectionsProcessed <span style="color:#f92672">&lt;</span> connectionQueueSize <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>newConnections<span style="color:#f92672">.</span>isEmpty<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">val</span> channel <span style="color:#66d9ef">=</span> newConnections<span style="color:#f92672">.</span>poll<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      debug<span style="color:#f92672">(</span><span style="color:#e6db74">s&#34;Processor </span><span style="color:#e6db74">$id</span><span style="color:#e6db74"> listening to new connection from </span><span style="color:#e6db74">${</span>channel<span style="color:#f92672">.</span>socket<span style="color:#f92672">.</span>getRemoteSocketAddress<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      selector<span style="color:#f92672">.</span>register<span style="color:#f92672">(</span>connectionId<span style="color:#f92672">(</span>channel<span style="color:#f92672">.</span>socket<span style="color:#f92672">),</span> channel<span style="color:#f92672">)</span> <span style="color:#75715e">// Register with Processor&#39;s own Selector (for OP_READ)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      connectionsProcessed <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> e<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Throwable</span> <span style="color:#f92672">=&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">val</span> remoteAddress <span style="color:#66d9ef">=</span> channel<span style="color:#f92672">.</span>socket<span style="color:#f92672">.</span>getRemoteSocketAddress
</span></span><span style="display:flex;"><span>        connectionQuotas<span style="color:#f92672">.</span>closeChannel<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> listenerName<span style="color:#f92672">,</span> channel<span style="color:#f92672">)</span> <span style="color:#75715e">// Cleanup on error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        processException<span style="color:#f92672">(</span><span style="color:#e6db74">s&#34;Processor </span><span style="color:#e6db74">$id</span><span style="color:#e6db74"> closed connection from </span><span style="color:#e6db74">$remoteAddress</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">,</span> e<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="processnewresponses">processNewResponses<a hidden class="anchor" aria-hidden="true" href="#processnewresponses">#</a></h2>
<p>Processes responses to be sent. Each Processor has a dedicated response queue (<strong><code>responseQueue</code></strong>). After processing a request, Handlers place the response into the corresponding Processor&rsquo;s <strong><code>responseQueue</code></strong>. This method:</p>
<ol>
<li>Checks if the associated Channel is closed.</li>
<li>Converts the <strong><code>Response</code></strong> into a network-ready packet (<strong><code>NetworkSend</code></strong>) and associates it with the Channel.</li>
<li><strong>Registers <code>OP_WRITE</code> events for the Channel</strong> (if not already registered).</li>
<li>(Note: Kafka uses a <strong><code>mute</code></strong>/<strong><code>unmute</code></strong> mechanism to manage per-Channel event registration, ensuring a Channel never has multiple in-flight requests/responses. Details covered later).</li>
</ol>
<h3 id="poll"><strong>poll</strong><a hidden class="anchor" aria-hidden="true" href="#poll">#</a></h3>
<p>Core network I/O operation. Calls <strong><code>Selector.poll(pollTimeout)</code></strong> (performing <strong><code>epoll_wait</code></strong>), handling all ready <strong><code>OP_READ</code></strong> and <strong><code>OP_WRITE</code></strong> events:</p>
<ul>
<li>
<p><strong><code>OP_READ</code></strong>: Reads data, handles TCP packet coalescing/splitting, assembles full requests.</p>
</li>
<li>
<p><strong><code>OP_WRITE</code></strong>: Sends the <strong><code>NetworkSend</code></strong> data associated with the Channel.</p>
<p><em>(Complex internals involving <strong><code>Selector</code></strong> implementation, <strong><code>NetworkReceive</code></strong>/<strong><code>NetworkSend</code></strong>, <strong><code>mute</code></strong>, etc., are covered in subsequent articles).</em></p>
</li>
</ul>
<h3 id="processcompletedreceives--processcompletedsends"><strong>processCompletedReceives / processCompletedSends</strong><a hidden class="anchor" aria-hidden="true" href="#processcompletedreceives--processcompletedsends">#</a></h3>
<p><strong><code>processCompletedReceives</code></strong> handles fully assembled requests (<strong><code>NetworkReceive</code></strong>) from the <strong><code>poll()</code></strong> phase:</p>
<ol>
<li>Parses <strong><code>NetworkReceive</code></strong> into a Kafka protocol <strong><code>Request</code></strong> object.</li>
<li>Places the <strong><code>Request</code></strong> into the <strong><code>RequestChannel</code></strong> queue for Handler processing.</li>
</ol>
<p><strong><code>processCompletedSends</code></strong> handles successfully sent responses (<strong><code>NetworkSend</code></strong>) from the <strong><code>poll()</code></strong> phase:</p>
<ol>
<li>Performs cleanup (e.g., releases <strong><code>ByteBuffer</code></strong>).</li>
<li><strong>Unmutes the Channel (calls <code>unmute()</code>)</strong> to allow it to listen for <strong><code>OP_READ</code></strong> events again (related to <strong><code>mute</code></strong> mechanism).</li>
</ol>
<h3 id="requestchannel"><strong>RequestChannel</strong><a hidden class="anchor" aria-hidden="true" href="#requestchannel">#</a></h3>
<p>Acts as the <strong>task queue between Processors and Handlers</strong>. Core is a <strong><code>BlockingQueue</code></strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RequestChannel</span><span style="color:#f92672">(</span><span style="color:#66d9ef">val</span> queueSize<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Int</span><span style="color:#f92672">,</span> <span style="color:#f92672">...)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">import</span> RequestChannel._
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">val</span> requestQueue <span style="color:#66d9ef">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ArrayBlockingQueue</span><span style="color:#f92672">[</span><span style="color:#66d9ef">BaseRequest</span><span style="color:#f92672">](</span>queueSize<span style="color:#f92672">)</span> <span style="color:#75715e">// Core Blocking Queue
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// ... (other fields and methods)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ul>
<li><strong>Processor (Producer):</strong> Calls <strong><code>RequestChannel.sendRequest(request)</code></strong> to enqueue parsed requests.</li>
<li><strong>Handler (Consumer):</strong> Calls <strong><code>RequestChannel.receiveRequest(timeout)</code></strong> to dequeue requests for processing.</li>
</ul>
<h3 id="kafkarequesthandler"><strong>KafkaRequestHandler</strong><a hidden class="anchor" aria-hidden="true" href="#kafkarequesthandler">#</a></h3>
<p>Threads in the worker thread pool (<strong><code>KafkaRequestHandlerPool</code></strong>). Their <strong><code>run()</code></strong> method loops to get requests from the <strong><code>RequestChannel</code></strong> (<strong><code>receiveRequest</code></strong>) and dispatches them to <strong><code>KafkaApis.handle(request)</code></strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">def</span> run<span style="color:#f92672">()</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Unit</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ... loop ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">val</span> req <span style="color:#66d9ef">=</span> requestChannel<span style="color:#f92672">.</span>receiveRequest<span style="color:#f92672">()</span> <span style="color:#75715e">// Get request from queue
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    apis<span style="color:#f92672">.</span>handle<span style="color:#f92672">(</span>req<span style="color:#f92672">,</span> requestLocal<span style="color:#f92672">)</span> <span style="color:#75715e">// Dispatch to KafkaApis for processing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong><code>KafkaApis.handle()</code></strong> is the entry point to Kafka&rsquo;s business logic. It routes requests based on type (<strong><code>ApiKeys</code></strong>) to specific handlers (e.g., <strong><code>handleProduceRequest</code></strong>, <strong><code>handleFetchRequest</code></strong>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-scala" data-lang="scala"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Top-level method that handles all requests and multiplexes to the right api
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">override</span> <span style="color:#66d9ef">def</span> handle<span style="color:#f92672">(</span>request<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RequestChannel.Request</span><span style="color:#f92672">,</span> requestLocal<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">RequestLocal</span><span style="color:#f92672">)</span><span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Unit</span> <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    trace<span style="color:#f92672">(</span><span style="color:#e6db74">s&#34;Handling request:</span><span style="color:#e6db74">${</span>request<span style="color:#f92672">.</span>requestDesc<span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span><span style="color:#e6db74">}</span><span style="color:#e6db74"> from connection </span><span style="color:#e6db74">${</span>request<span style="color:#f92672">.</span>context<span style="color:#f92672">.</span>connectionId<span style="color:#e6db74">}</span><span style="color:#e6db74">;...&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>apiVersionManager<span style="color:#f92672">.</span>isApiEnabled<span style="color:#f92672">(</span>request<span style="color:#f92672">.</span>header<span style="color:#f92672">.</span>apiKey<span style="color:#f92672">,</span> request<span style="color:#f92672">.</span>header<span style="color:#f92672">.</span>apiVersion<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">IllegalStateException</span><span style="color:#f92672">(</span><span style="color:#e6db74">s&#34;API </span><span style="color:#e6db74">${</span>request<span style="color:#f92672">.</span>header<span style="color:#f92672">.</span>apiKey<span style="color:#e6db74">}</span><span style="color:#e6db74"> with version </span><span style="color:#e6db74">${</span>request<span style="color:#f92672">.</span>header<span style="color:#f92672">.</span>apiVersion<span style="color:#e6db74">}</span><span style="color:#e6db74"> is not enabled&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    request<span style="color:#f92672">.</span>header<span style="color:#f92672">.</span>apiKey <span style="color:#66d9ef">match</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// Dispatch based on request type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">ApiKeys</span><span style="color:#f92672">.</span><span style="color:#a6e22e">PRODUCE</span> <span style="color:#66d9ef">=&gt;</span> handleProduceRequest<span style="color:#f92672">(</span>request<span style="color:#f92672">,</span> requestLocal<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">ApiKeys</span><span style="color:#f92672">.</span><span style="color:#a6e22e">FETCH</span> <span style="color:#66d9ef">=&gt;</span> handleFetchRequest<span style="color:#f92672">(</span>request<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">ApiKeys</span><span style="color:#f92672">.</span><span style="color:#a6e22e">LIST_OFFSETS</span> <span style="color:#66d9ef">=&gt;</span> handleListOffsetRequest<span style="color:#f92672">(</span>request<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">ApiKeys</span><span style="color:#f92672">.</span><span style="color:#a6e22e">METADATA</span> <span style="color:#66d9ef">=&gt;</span> handleTopicMetadataRequest<span style="color:#f92672">(</span>request<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">ApiKeys</span><span style="color:#f92672">.</span><span style="color:#a6e22e">OFFSET_COMMIT</span> <span style="color:#66d9ef">=&gt;</span> handleOffsetCommitRequest<span style="color:#f92672">(</span>request<span style="color:#f92672">,</span> requestLocal<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// ... (handlers for all other API keys) ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">ApiKeys</span><span style="color:#f92672">.</span><span style="color:#a6e22e">API_VERSIONS</span> <span style="color:#66d9ef">=&gt;</span> handleApiVersionsRequest<span style="color:#f92672">(</span>request<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> e<span style="color:#66d9ef">:</span> <span style="color:#66d9ef">Throwable</span> <span style="color:#f92672">=&gt;</span> requestHelper<span style="color:#f92672">.</span>handleError<span style="color:#f92672">(</span>request<span style="color:#f92672">,</span> e<span style="color:#f92672">)</span> <span style="color:#75715e">// Handle processing errors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>After processing, the Handler constructs a <strong><code>Response</code></strong> and sends it back to the corresponding Processor via <strong><code>RequestChannel.sendResponse()</code></strong> (using the associated response queue). The Processor then sends it to the client.</p>
<hr>
<h1 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h1>
<p>This article dissected how Kafka leverages the <strong>Reactor pattern</strong> (Single Acceptor + Multiple Processors + RequestChannel Queue + Handler Thread Pool) to achieve high-throughput network processing:</p>
<ol>
<li><strong>Acceptor</strong> efficiently accepts and distributes new connections.</li>
<li><strong>Processor</strong> uses NIO (<strong><code>epoll</code></strong>) to efficiently handle I/O events for many connections (I/O-bound).</li>
<li><strong>RequestChannel</strong> decouples network I/O (Processor) from business processing (Handler), buffering requests.</li>
<li><strong>Handler</strong> thread pool focuses on business logic (CPU/disk-bound).</li>
</ol>
<p>This architecture effectively isolates different task stages, maximizes multi-core CPU utilization, and smooths traffic fluctuations via queue buffering, forming the foundation of Kafka&rsquo;s high throughput and concurrency.</p>
<p>We focused on the request flow mapping to the Reactor pattern, omitting details like network I/O (packet handling, <strong><code>Selector</code></strong> internals, <strong><code>mute</code></strong> mechanism), request parsing, and Handler internals. These will be explored in future articles.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://cyrilwongmy.github.io/">Mingyan&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>

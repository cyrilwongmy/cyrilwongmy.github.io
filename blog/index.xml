<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Blogs on Mingyan&#39;s blog</title>
    <link>https://cyrilwongmy.github.io/blog/</link>
    <description>Recent content in Blogs on Mingyan&#39;s blog</description>
    <generator>Hugo -- 0.147.3</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 29 May 2025 22:03:53 -0700</lastBuildDate>
    <atom:link href="https://cyrilwongmy.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kafka’s TCP Unpacking: A Production-Grade Code Walkthrough (Part 1)</title>
      <link>https://cyrilwongmy.github.io/blog/01-kafka-01-tcp-fragmentation/</link>
      <pubDate>Thu, 29 May 2025 22:03:53 -0700</pubDate>
      <guid>https://cyrilwongmy.github.io/blog/01-kafka-01-tcp-fragmentation/</guid>
      <description>&lt;p&gt;The source code referenced in this article uses Kafka&amp;rsquo;s trunk branch. I&amp;rsquo;ve pushed it to my personal repo for version alignment with this article:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/cyrilwongmy/kafka-src-reading&#34;&gt;https://github.com/cyrilwongmy/kafka-src-reading&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;tcp-and-packet-fragmentation&#34;&gt;&lt;strong&gt;TCP and Packet Fragmentation&lt;/strong&gt;&lt;/h1&gt;
&lt;h2 id=&#34;why-does-tcp-require-packet-fragmentation&#34;&gt;&lt;strong&gt;Why Does TCP Require Packet Fragmentation?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Kafka uses TCP as its underlying transport layer protocol. TCP operates as a continuous byte stream without inherent message boundaries. Therefore, any application using TCP must implement its own mechanism to delineate message boundaries.&lt;/p&gt;
&lt;h2 id=&#34;how-to-implement-packet-fragmentation&#34;&gt;&lt;strong&gt;How to Implement Packet Fragmentation?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;When writing data to TCP, the sender must explicitly mark message boundaries. Typically, we first write a fixed 4-byte header indicating the size of the subsequent message (4 bytes can represent messages up to 4GB). The receiver first reads these 4 bytes to determine the &lt;strong&gt;&lt;code&gt;message_size&lt;/code&gt;&lt;/strong&gt;, then reads exactly &lt;strong&gt;&lt;code&gt;message_size&lt;/code&gt;&lt;/strong&gt; bytes from the network to reconstruct the complete message.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

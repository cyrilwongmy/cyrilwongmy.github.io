<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kafka’s TCP Unpacking: A Production-Grade Code Walkthrough (Part 1) | Mingyan&#39;s blog</title>
<meta name="keywords" content="">
<meta name="description" content="This is part 1 of the Kafka series. The Kafka series is a series of blog posts that will introduce the design and implementation details of Kafka.
The source code referenced in this article uses Kafka&rsquo;s trunk branch. I&rsquo;ve pushed it to my personal repo for version alignment with this article:
https://github.com/cyrilwongmy/kafka-src-reading
TCP and Packet Fragmentation
Why Does TCP Require Packet Fragmentation?
Kafka uses TCP as its underlying transport layer protocol. TCP operates as a continuous byte stream without inherent message boundaries. Therefore, any application using TCP must implement its own mechanism to delineate message boundaries.">
<meta name="author" content="">
<link rel="canonical" href="https://cyrilwongmy.github.io/blog/01-kafka-01-tcp-fragmentation/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://cyrilwongmy.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://cyrilwongmy.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://cyrilwongmy.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://cyrilwongmy.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://cyrilwongmy.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://cyrilwongmy.github.io/blog/01-kafka-01-tcp-fragmentation/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://cyrilwongmy.github.io/blog/01-kafka-01-tcp-fragmentation/">
  <meta property="og:site_name" content="Mingyan&#39;s blog">
  <meta property="og:title" content="Kafka’s TCP Unpacking: A Production-Grade Code Walkthrough (Part 1)">
  <meta property="og:description" content="This is part 1 of the Kafka series. The Kafka series is a series of blog posts that will introduce the design and implementation details of Kafka.
The source code referenced in this article uses Kafka’s trunk branch. I’ve pushed it to my personal repo for version alignment with this article:
https://github.com/cyrilwongmy/kafka-src-reading
TCP and Packet Fragmentation Why Does TCP Require Packet Fragmentation? Kafka uses TCP as its underlying transport layer protocol. TCP operates as a continuous byte stream without inherent message boundaries. Therefore, any application using TCP must implement its own mechanism to delineate message boundaries.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2025-05-29T22:03:53-07:00">
    <meta property="article:modified_time" content="2025-05-29T22:03:53-07:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kafka’s TCP Unpacking: A Production-Grade Code Walkthrough (Part 1)">
<meta name="twitter:description" content="This is part 1 of the Kafka series. The Kafka series is a series of blog posts that will introduce the design and implementation details of Kafka.
The source code referenced in this article uses Kafka&rsquo;s trunk branch. I&rsquo;ve pushed it to my personal repo for version alignment with this article:
https://github.com/cyrilwongmy/kafka-src-reading
TCP and Packet Fragmentation
Why Does TCP Require Packet Fragmentation?
Kafka uses TCP as its underlying transport layer protocol. TCP operates as a continuous byte stream without inherent message boundaries. Therefore, any application using TCP must implement its own mechanism to delineate message boundaries.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://cyrilwongmy.github.io/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Kafka’s TCP Unpacking: A Production-Grade Code Walkthrough (Part 1)",
      "item": "https://cyrilwongmy.github.io/blog/01-kafka-01-tcp-fragmentation/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kafka’s TCP Unpacking: A Production-Grade Code Walkthrough (Part 1)",
  "name": "Kafka’s TCP Unpacking: A Production-Grade Code Walkthrough (Part 1)",
  "description": "This is part 1 of the Kafka series. The Kafka series is a series of blog posts that will introduce the design and implementation details of Kafka.\nThe source code referenced in this article uses Kafka\u0026rsquo;s trunk branch. I\u0026rsquo;ve pushed it to my personal repo for version alignment with this article:\nhttps://github.com/cyrilwongmy/kafka-src-reading\nTCP and Packet Fragmentation Why Does TCP Require Packet Fragmentation? Kafka uses TCP as its underlying transport layer protocol. TCP operates as a continuous byte stream without inherent message boundaries. Therefore, any application using TCP must implement its own mechanism to delineate message boundaries.\n",
  "keywords": [
    
  ],
  "articleBody": "This is part 1 of the Kafka series. The Kafka series is a series of blog posts that will introduce the design and implementation details of Kafka.\nThe source code referenced in this article uses Kafka’s trunk branch. I’ve pushed it to my personal repo for version alignment with this article:\nhttps://github.com/cyrilwongmy/kafka-src-reading\nTCP and Packet Fragmentation Why Does TCP Require Packet Fragmentation? Kafka uses TCP as its underlying transport layer protocol. TCP operates as a continuous byte stream without inherent message boundaries. Therefore, any application using TCP must implement its own mechanism to delineate message boundaries.\nHow to Implement Packet Fragmentation? When writing data to TCP, the sender must explicitly mark message boundaries. Typically, we first write a fixed 4-byte header indicating the size of the subsequent message (4 bytes can represent messages up to 4GB). The receiver first reads these 4 bytes to determine the message_size, then reads exactly message_size bytes from the network to reconstruct the complete message.\n| message size (4 bytes) | message | message size (4 bytes) | message | ... Kafka’s Packet Fragmentation Implementation The class handling TCP packet fragmentation in Kafka is NetworkReceive, which implements the approach described above.\nNote its definition and constructor. The size and buffer fields correspond directly to the message size header and message content in the above section:\n/** * A size-delimited Receive consisting of a 4-byte network-ordered size N * followed by N bytes of content */ public class NetworkReceive implements Receive { public static final String UNKNOWN_SOURCE = \"\"; public static final int UNLIMITED = -1; private static final Logger log = LoggerFactory.getLogger(NetworkReceive.class); private static final ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0); private final String source; private final ByteBuffer size; private final int maxSize; private final MemoryPool memoryPool; private int requestedBufferSize = -1; private ByteBuffer buffer; // ... public NetworkReceive(int maxSize, String source, MemoryPool memoryPool) { this.source = source; this.size = ByteBuffer.allocate(4); // 4-byte size header this.buffer = null; // Will hold message content this.maxSize = maxSize; this.memoryPool = memoryPool; } Implementing Fragmentation Logic: NetworkReceive.readFrom This method reads data from a ScatteringByteChannel (representing network data) into the NetworkReceive object. The process has two phases:\nRead size header: If the 4-byte size header isn’t fully read, continue reading into the size buffer. Read message content: After obtaining the full size header, convert it to an integer (receiveSize), allocate a buffer of that size, and read receiveSize bytes from the channel. In this way, we don’t need a dynamically expandable byte array, which reduces the copy of underlying data. Data from network are only written into memory once. public long readFrom(ScatteringByteChannel channel) throws IOException { int read = 0; // Phase 1: Read 4-byte size header if (size.hasRemaining()) { int bytesRead = channel.read(size); if (bytesRead \u003c 0) throw new EOFException(); read += bytesRead; if (!size.hasRemaining()) { // Header complete size.rewind(); int receiveSize = size.getInt(); // Extract message size if (receiveSize \u003c 0) throw new InvalidReceiveException(\"Invalid size: \" + receiveSize); if (maxSize != UNLIMITED \u0026\u0026 receiveSize \u003e maxSize) throw new InvalidReceiveException(\"Size \" + receiveSize + \" exceeds limit \" + maxSize); requestedBufferSize = receiveSize; if (receiveSize == 0) buffer = EMPTY_BUFFER; } } // Phase 2: Read message content if (buffer == null \u0026\u0026 requestedBufferSize != -1) { buffer = memoryPool.tryAllocate(requestedBufferSize); // Allocate buffer if (buffer == null) log.trace(\"Memory low - failed allocation size {} for {}\", requestedBufferSize, source); } if (buffer != null) { int bytesRead = channel.read(buffer); // Read content if (bytesRead \u003c 0) throw new EOFException(); read += bytesRead; } return read; } Other helper methods are omitted for brevity. Explore the full source in the repo.\nSender Implementation: NetworkSend On the sender side, we must format messages as message size (4 bytes) + message.\nKafka’s NetworkSend differs slightly from NetworkReceive due to zero-copy optimizations. We’ll focus on the basic in-memory approach here (zero-copy will be covered later).\nNetworkSend uses composition with the Send interface instead of direct size/buffer fields. Crucially, NetworkSend.writeTo() delegates to its contained Send object:\npublic class NetworkSend implements Send { private final String destinationId; private final Send send; // Delegates core functionality // Constructor and methods omitted... @Override public long writeTo(TransferableChannel channel) throws IOException { return send.writeTo(channel); // Delegation } } The Send interface defines the critical packet writing behavior:\npublic interface Send { boolean completed(); long writeTo(TransferableChannel channel) throws IOException; // Core method long size(); } The simplest implementation is ByteBufferSend. Its static factory sizePrefixed() constructs the required 4-byte header + message format:\npublic static ByteBufferSend sizePrefixed(ByteBuffer buffer) { ByteBuffer sizeBuffer = ByteBuffer.allocate(4); sizeBuffer.putInt(0, buffer.remaining()); // Write size header return new ByteBufferSend(sizeBuffer, buffer); // Header + Content } Its writeTo() method writes all buffers in one operation:\n@Override public long writeTo(TransferableChannel channel) throws IOException { long written = channel.write(buffers); // Write all buffers if (written \u003c 0) throw new EOFException(); remaining -= written; pending = channel.hasPendingWrites(); return written; } Kafka’s Network Channel Abstraction If you’re not familiar with Java NIO API, there are a few resources online.\nKafka wraps Java NIO APIs. The ScatteringByteChannel used by NetworkReceive is implemented by PlaintextTransportLayer:\nPlaintextTransportLayer has a field SocketChannel, which is used for interacting with internet over socket. PlaintextTransportLayer delegates handling of read functionality directly to a JDK SocketChannel. SocketChannel will perform the actual read from network socket.\n@Override public int read(ByteBuffer dst) throws IOException { return socketChannel.read(dst); // Direct delegation } @Override public long read(ByteBuffer[] dsts) throws IOException { return socketChannel.read(dsts); } @Override public long read(ByteBuffer[] dsts, int offset, int length) throws IOException { return socketChannel.read(dsts, offset, length); } Conclusion This blog demonstrates how Kafka implements TCP packet fragmentation. You can adapt this pattern to define custom message formats by encoding/decoding your content after handling fragmentation. If you have any question, free feel to leave issues at this repo.\n",
  "wordCount" : "954",
  "inLanguage": "en",
  "datePublished": "2025-05-29T22:03:53-07:00",
  "dateModified": "2025-05-29T22:03:53-07:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://cyrilwongmy.github.io/blog/01-kafka-01-tcp-fragmentation/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mingyan's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://cyrilwongmy.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://cyrilwongmy.github.io/" accesskey="h" title="Mingyan&#39;s blog (Alt + H)">Mingyan&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Kafka’s TCP Unpacking: A Production-Grade Code Walkthrough (Part 1)
    </h1>
    <div class="post-meta"><span title='2025-05-29 22:03:53 -0700 PDT'>May 29, 2025</span>

</div>
  </header> 
  <div class="post-content"><p>This is part 1 of the Kafka series. The Kafka series is a series of blog posts that will introduce the design and implementation details of Kafka.</p>
<p>The source code referenced in this article uses Kafka&rsquo;s trunk branch. I&rsquo;ve pushed it to my personal repo for version alignment with this article:</p>
<p><a href="https://github.com/cyrilwongmy/kafka-src-reading">https://github.com/cyrilwongmy/kafka-src-reading</a></p>
<h1 id="tcp-and-packet-fragmentation"><strong>TCP and Packet Fragmentation</strong><a hidden class="anchor" aria-hidden="true" href="#tcp-and-packet-fragmentation">#</a></h1>
<h2 id="why-does-tcp-require-packet-fragmentation"><strong>Why Does TCP Require Packet Fragmentation?</strong><a hidden class="anchor" aria-hidden="true" href="#why-does-tcp-require-packet-fragmentation">#</a></h2>
<p>Kafka uses TCP as its underlying transport layer protocol. TCP operates as a continuous byte stream without inherent message boundaries. Therefore, any application using TCP must implement its own mechanism to delineate message boundaries.</p>
<h2 id="how-to-implement-packet-fragmentation"><strong>How to Implement Packet Fragmentation?</strong><a hidden class="anchor" aria-hidden="true" href="#how-to-implement-packet-fragmentation">#</a></h2>
<p>When writing data to TCP, the sender must explicitly mark message boundaries. Typically, we first write a fixed 4-byte header indicating the size of the subsequent message (4 bytes can represent messages up to 4GB). The receiver first reads these 4 bytes to determine the <strong><code>message_size</code></strong>, then reads exactly <strong><code>message_size</code></strong> bytes from the network to reconstruct the complete message.</p>
<pre tabindex="0"><code>| message size (4 bytes) | message | message size (4 bytes) | message | ...
</code></pre><h1 id="kafka"><strong>Kafka&rsquo;s Packet Fragmentation Implementation</strong><a hidden class="anchor" aria-hidden="true" href="#kafka">#</a></h1>
<p>The class handling TCP packet fragmentation in Kafka is <strong><code>NetworkReceive</code></strong>, which implements the approach described above.</p>
<p>Note its definition and constructor. The <strong><code>size</code></strong> and <strong><code>buffer</code></strong> fields correspond directly to the message size header and message content in the above section:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * A size-delimited Receive consisting of a 4-byte network-ordered size N 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * followed by N bytes of content
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NetworkReceive</span> <span style="color:#66d9ef">implements</span> Receive {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> String UNKNOWN_SOURCE <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> UNLIMITED <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Logger log <span style="color:#f92672">=</span> LoggerFactory.<span style="color:#a6e22e">getLogger</span>(NetworkReceive.<span style="color:#a6e22e">class</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> ByteBuffer EMPTY_BUFFER <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">allocate</span>(0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> String source;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> ByteBuffer size;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> maxSize;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> MemoryPool memoryPool;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> requestedBufferSize <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> ByteBuffer buffer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">NetworkReceive</span>(<span style="color:#66d9ef">int</span> maxSize, String source, MemoryPool memoryPool) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">source</span> <span style="color:#f92672">=</span> source;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">allocate</span>(4); <span style="color:#75715e">// 4-byte size header</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">buffer</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// Will hold message content</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">maxSize</span> <span style="color:#f92672">=</span> maxSize;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">memoryPool</span> <span style="color:#f92672">=</span> memoryPool;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="implementing-fragmentation-logic-networkreceivereadfrom"><strong>Implementing Fragmentation Logic: NetworkReceive.readFrom</strong><a hidden class="anchor" aria-hidden="true" href="#implementing-fragmentation-logic-networkreceivereadfrom">#</a></h2>
<p>This method reads data from a <strong><code>ScatteringByteChannel</code></strong> (representing network data) into the <strong><code>NetworkReceive</code></strong> object. The process has two phases:</p>
<ol>
<li><strong>Read size header:</strong> If the 4-byte size header isn&rsquo;t fully read, continue reading into the <strong><code>size</code></strong> buffer.</li>
<li><strong>Read message content:</strong> After obtaining the full size header, convert it to an integer (<strong><code>receiveSize</code></strong>), allocate a buffer of that size, and read <strong><code>receiveSize</code></strong> bytes from the channel. In this way, we don’t need a <strong>dynamically expandable byte array</strong>, which reduces the copy of underlying data. <strong>Data from network are only written into memory once</strong>.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">readFrom</span>(ScatteringByteChannel channel) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> read <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Phase 1: Read 4-byte size header</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (size.<span style="color:#a6e22e">hasRemaining</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> bytesRead <span style="color:#f92672">=</span> channel.<span style="color:#a6e22e">read</span>(size);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">&lt;</span> 0) <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> EOFException();
</span></span><span style="display:flex;"><span>        read <span style="color:#f92672">+=</span> bytesRead;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>size.<span style="color:#a6e22e">hasRemaining</span>()) { <span style="color:#75715e">// Header complete</span>
</span></span><span style="display:flex;"><span>            size.<span style="color:#a6e22e">rewind</span>();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> receiveSize <span style="color:#f92672">=</span> size.<span style="color:#a6e22e">getInt</span>(); <span style="color:#75715e">// Extract message size</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (receiveSize <span style="color:#f92672">&lt;</span> 0) <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidReceiveException(<span style="color:#e6db74">&#34;Invalid size: &#34;</span> <span style="color:#f92672">+</span> receiveSize);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (maxSize <span style="color:#f92672">!=</span> UNLIMITED <span style="color:#f92672">&amp;&amp;</span> receiveSize <span style="color:#f92672">&gt;</span> maxSize) <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidReceiveException(<span style="color:#e6db74">&#34;Size &#34;</span> <span style="color:#f92672">+</span> receiveSize <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; exceeds limit &#34;</span> <span style="color:#f92672">+</span> maxSize);
</span></span><span style="display:flex;"><span>            requestedBufferSize <span style="color:#f92672">=</span> receiveSize;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (receiveSize <span style="color:#f92672">==</span> 0) buffer <span style="color:#f92672">=</span> EMPTY_BUFFER;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Phase 2: Read message content</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (buffer <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> requestedBufferSize <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1) {
</span></span><span style="display:flex;"><span>        buffer <span style="color:#f92672">=</span> memoryPool.<span style="color:#a6e22e">tryAllocate</span>(requestedBufferSize); <span style="color:#75715e">// Allocate buffer</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (buffer <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) log.<span style="color:#a6e22e">trace</span>(<span style="color:#e6db74">&#34;Memory low - failed allocation size {} for {}&#34;</span>, requestedBufferSize, source);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (buffer <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> bytesRead <span style="color:#f92672">=</span> channel.<span style="color:#a6e22e">read</span>(buffer); <span style="color:#75715e">// Read content</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (bytesRead <span style="color:#f92672">&lt;</span> 0) <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> EOFException();
</span></span><span style="display:flex;"><span>        read <span style="color:#f92672">+=</span> bytesRead;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> read;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Other helper methods are omitted for brevity. Explore the full source in the <a href="https://github.com/cyrilwongmy/kafka-src-reading">repo</a>.</p>
<h1 id="sender-implementation-networksend"><strong>Sender Implementation: NetworkSend</strong><a hidden class="anchor" aria-hidden="true" href="#sender-implementation-networksend">#</a></h1>
<p>On the sender side, we must format messages as <strong><code>message size (4 bytes) + message</code></strong>.</p>
<p>Kafka&rsquo;s <strong><code>NetworkSend</code></strong> differs slightly from <strong><code>NetworkReceive</code></strong> due to zero-copy optimizations. We&rsquo;ll focus on the basic in-memory approach here (zero-copy will be covered later).</p>
<p><img alt="Send" loading="lazy" src="https://raw.githubusercontent.com/cyrilwongmy/cyrilwongmy.github.io/main/assets/image/image.png"></p>
<p><strong><code>NetworkSend</code></strong> uses composition with the <strong><code>Send</code></strong> interface instead of direct <strong><code>size</code></strong>/<strong><code>buffer</code></strong> fields. Crucially, <strong><code>NetworkSend.writeTo()</code></strong> delegates to its contained <strong><code>Send</code></strong> object:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NetworkSend</span> <span style="color:#66d9ef">implements</span> Send {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> String destinationId;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Send send; <span style="color:#75715e">// Delegates core functionality</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Constructor and methods omitted...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">writeTo</span>(TransferableChannel channel) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> send.<span style="color:#a6e22e">writeTo</span>(channel); <span style="color:#75715e">// Delegation</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <strong><code>Send</code></strong> interface defines the critical packet writing behavior:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Send</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">completed</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">writeTo</span>(TransferableChannel channel) <span style="color:#66d9ef">throws</span> IOException; <span style="color:#75715e">// Core method</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">size</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The simplest implementation is <strong><code>ByteBufferSend</code></strong>. Its static factory <strong><code>sizePrefixed()</code></strong> constructs the required 4-byte header + message format:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ByteBufferSend <span style="color:#a6e22e">sizePrefixed</span>(ByteBuffer buffer) {
</span></span><span style="display:flex;"><span>    ByteBuffer sizeBuffer <span style="color:#f92672">=</span> ByteBuffer.<span style="color:#a6e22e">allocate</span>(4);
</span></span><span style="display:flex;"><span>    sizeBuffer.<span style="color:#a6e22e">putInt</span>(0, buffer.<span style="color:#a6e22e">remaining</span>()); <span style="color:#75715e">// Write size header</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ByteBufferSend(sizeBuffer, buffer); <span style="color:#75715e">// Header + Content</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><img alt="Kafka" loading="lazy" src="https://raw.githubusercontent.com/cyrilwongmy/cyrilwongmy.github.io/main/assets/image/Kafka.png"></p>
<p>Its <strong><code>writeTo()</code></strong> method writes all buffers in one operation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">writeTo</span>(TransferableChannel channel) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> written <span style="color:#f92672">=</span> channel.<span style="color:#a6e22e">write</span>(buffers); <span style="color:#75715e">// Write all buffers</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (written <span style="color:#f92672">&lt;</span> 0) <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> EOFException();
</span></span><span style="display:flex;"><span>    remaining <span style="color:#f92672">-=</span> written;
</span></span><span style="display:flex;"><span>    pending <span style="color:#f92672">=</span> channel.<span style="color:#a6e22e">hasPendingWrites</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> written;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="kafka-1"><strong>Kafka&rsquo;s Network Channel Abstraction</strong><a hidden class="anchor" aria-hidden="true" href="#kafka-1">#</a></h1>
<p>If you&rsquo;re not familiar with Java NIO API, there are a few resources online.</p>
<p>Kafka wraps Java NIO APIs. The <strong><code>ScatteringByteChannel</code></strong> used by <strong><code>NetworkReceive</code></strong> is implemented by <strong><code>PlaintextTransportLayer</code></strong>:</p>
<p><img alt="Channel" loading="lazy" src="https://raw.githubusercontent.com/cyrilwongmy/cyrilwongmy.github.io/main/assets/image/image_1.png"></p>
<p><strong><code>PlaintextTransportLayer</code></strong>  has a field <code>SocketChannel</code>, which is used for interacting with internet over socket. <code>PlaintextTransportLayer</code> delegates handling of read functionality directly to a JDK <strong><code>SocketChannel</code></strong>. <code>SocketChannel</code> will perform the actual read from network socket.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">read</span>(ByteBuffer dst) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> socketChannel.<span style="color:#a6e22e">read</span>(dst); <span style="color:#75715e">// Direct delegation</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">read</span>(ByteBuffer<span style="color:#f92672">[]</span> dsts) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> socketChannel.<span style="color:#a6e22e">read</span>(dsts);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">read</span>(ByteBuffer<span style="color:#f92672">[]</span> dsts, <span style="color:#66d9ef">int</span> offset, <span style="color:#66d9ef">int</span> length) <span style="color:#66d9ef">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> socketChannel.<span style="color:#a6e22e">read</span>(dsts, offset, length);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="conclusion"><strong>Conclusion</strong><a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>This blog demonstrates how Kafka implements TCP packet fragmentation. You can adapt this pattern to define custom message formats by encoding/decoding your content after handling fragmentation. If you have any question, free feel to leave issues at this <a href="https://github.com/cyrilwongmy/kafka-src-reading">repo</a>.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://cyrilwongmy.github.io/">Mingyan&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
